1. Data types:-

    ->  Value types:- Value types are types that are directly stored in memory and copied
          1. Address:- it stores address(20 bytes) and divdied into two types
                    - address payable:- can recieve payment also 
                    - address:- cannot recieve payment
               -> you cannot store string in address it can hold only 20-byte Ethereum address
          
          2. Bytes:- this can store a sequece fixed-length binary Data
                    - bytes1 onebyte = 0xAA;
                    - bytes32 onebyte = 0xAAoisdfjsddkjfslkdlksdjklsdfsdjfkdsjksdlj;       
          
          3. Fixed Pointed Numbers:- represents a decimal number with a fixed number of decimal places
               -> fixed64x3 fixedNumber = 123.456;
               -> ufixed64x8 ufixedNumber = -123.4569090;


    ->  Refrence Types:- these store a reference location of the data, rather than the data itself.

          1. Strings:- 
               -> you cannot directly do this (string myString = "vik" + "ram";) insted assign a variable to two 
                  strings and use (+) operator
               -> other way is by using [ string (abi.encodePacked("ram", "nam")); ]
               -> str1.concat(str2);
               -> use memory keyword

          2. Struct:- 
               -> you need memory keyword the same way as  
               -> Person alice = Person("noothan", 19);

          3. Arrays:-
               1. Fixed array:- int[5] arr;
               1. Dynamic array:- int[] arr;
               -> you need memory keyword the same way as string in functions  
               -> you can use a dynamic array as a function argument or return value 
               -> mapping(address => int[]) myMapping;
               -> you cannot iterate on empty arrays 

          4. Mapping:-  they key-value pair and are similar to hash table/dictionary
               -> mapping(address => uint) balances;
               -> you can access any key like this balances[address]; 

          5. Enums:-  allow you to define a set of named constants
               -> enum Color { Red = 10, Green = 20, Blue = 30 }  // Define an enum with custom values here by default value
                    is 0, 1, 2 but by writing this we overide it
               -> you Can use an enum as the key or value type in a mapping     // colorCounts[Color.Red] = 10;
               -> you Can define an enum inside a struct
               -> you Can use an enum as a function argument or return value    // return colorCounts[color];

2. Control structures:- 
     
     -> loops:-  
          1. Solidity does not allow infinite loops, and it has a maximum number of iterations for loops to prevent potential gas exhaustion.
          2. you cannot iterate over the dynamic arrays 
     
     -> If-else:- 
          1. you cannot use it outside functions
     
     -> Require Function:-
          1. require(condition, "Error message");

     -> Assert Statements:- 
 
3. Functions:-
    
    -> function modifiers:- 
       same as modifiers explained
          
    -> function visiblity:-
          1. public:- called from outside and other contracts
          2. private:- within contract
          3. internal:- within and child contract
          4. external:- only from external contaracts

5. Modifiers:- 
     eg:- 
            modifier onlyOwner {
                require(msg.sender == owner, "Only the owner can emit this event.");
                _;
            }
            function emitMyEvent(uint256 value) public onlyOwner {
                emit MyEvent(value);
            }
            
          1. these special functions are the used to check conditions and modify the 
          2. modifiers can be used in other modifiers 
          3. we can assign multiple modifiers to a single function
          4. Modifiers can also be inherited by child contracts from parent 

















 
